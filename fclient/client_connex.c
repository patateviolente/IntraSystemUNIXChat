#include "../headers/client_connex.h"


/**
 * This procedure should ask server to create a pipe named like pseudo:pipe_num
 * with :
 * <ul>
 * 		<li>Pseudo : a string entered by user</li>
 * 		<li>Pipe_num : a random string generated by client, to make a hard name 
 * 			(cf security schema)</li>
 * </ul>
 * 
 * @return Connexion status<ul>
 * 		<li>0 : if connexion established</li>
 * 		<li>-1 : if no pipe detected or no anwser readen</li>
 * 		<li>EXIT if server is not running (0)</li>
 * </ul>
 */
int connexion(){

	int fd_write, fd_read, n, i;
	int attempt = 0;
	
	// mutex for pipe
	int mutc;
	key_t key;
	
	// strcat
	char login[MAX_LOGIN_LENGTH];
	char password[MAX_PWD_LENGTH];
	
	// buffer message
	char sendBuf[CONNECT_ASK_MSG];
	char recvBuf[CONNECT_ANS_MSG];	
	
	key = ftok("/etc/magic",1);
	if( (mutc = mutalloc(key)) == -1){
		puts("Erreur mutalloc mutc(7)");
		exitChat();
	}
	
	//////////////////////////////
	// First part : send login & password & pid & pipe number
	// opening pipe
	if (( fd_write = open (CONNEXION_PIPE, O_WRONLY)) == -1) {
		puts (" > Chat server is not running ! Can't access connexion pipe.");
		V(mutc);
		exit (0);
	}
	
	// -1- getting login
	printf("<< Please enter your login : ");
	readKeyboard(login, MAX_LOGIN_LENGTH);
	strcpy(pipename,login);

	// -2- getting password
	printf("<< Please enter your password : ");
	getThisPass(&password);
	
	// -3- getting pid
	pid = getpid();

	// writing -> login:password:pid:pipe_nume\n
	sprintf(sendBuf,"%s:%s:%d:%s\n",login,password,pid,pipe_num);
	
	// Zone critique : Ã©criture dans le pipe (plusieurs utilisateurs possibles)
    P(mutc);
	if (( n = write(fd_write,sendBuf,CONNECT_ASK_MSG)) == -1) {
		perror ("Can't write to server");
		V(mutc);
		exit (30);
	}
	V(mutc);
	printf("   * Demand transmitted * : ... waiting for response...");
	close (fd_write);



	//////////////////////////////
	// Second part : test server answer and waiting for pipe pipename
	// 1. waiting for pipe creation
	// name of the pipe : login.number
	// 2. And get pseudo and num generated by server
	
	strcat(pipename, pipe_num);

	//chdir(PIPE_FOLDER);
	while(1)
	{
		// will block...
		if (( fd_read = open(pipename, O_RDONLY)) == -1) {
			usleep(5000);
			printf(" .");
			fflush(stdout);
			if(attempt++ == 100){
				printf("\n No server answer, no pipe detected (pipe \"%s\") !\n", pipename);
				return -1;
			}
		}
		else{
			puts("\n > Server have created pipe ! Reading answer ...");
			// 2. is client accepted ?
			if ( read(fd_read, recvBuf,CONNECT_ANS_MSG) != -1){
			
			    // -4- getting num and pseudo
				if(parseConnexionAnswer(recvBuf,&num,pseudo,&type)) {
					perror(" Can't parse server answered");
					exit(60);
				}
				printf("    > My pseudo is *%s* and num=%ld\n",pseudo,num);
				break;
			} else{
				printf("NO ANSWER - connexion failed.\n");
				return -1;
			}
			close(fd_read);
			//break;
		}
	}
	
	/////////////////////////////////////////////////////////////////
	// ... appeler pipe de lecture du chat, ouvrir l'interface etc...
	return 0;
}


// possible de pas envoyer pseudo et num (car global au prog)
int parseConnexionAnswer(char* str ,long int* num,char* pseudo, int * type) { 
	int i=0, u=0,l=0;
	char num_char[MAX_NUMGEN];
	char type_char[MAX_NUMGEN];
	while(str[i] != ':'){
		if(i == MAX_NUMGEN) return -1;
		num_char[i] = str[i];
		i++;
	}
	num_char[i] = '\0';
	*num = atol (num_char); // les opticiens
	i++;
	while(str[i] != ':'){
		if(u == MAX_PSEUDO_LENGTH) return -1;
		pseudo[u] = str[i];
		i++;u++;
	}
	pseudo[u] = '\0';
	i++;
	while(str[i] != '\n'){
		if(l == MAX_PSEUDO_LENGTH) return -1;
		type_char[l] = str[i];
		i++;l++;
	}
	type_char[i] = '\0';
	*type = atoi (type_char); // les opticiens
	return 0;
}

